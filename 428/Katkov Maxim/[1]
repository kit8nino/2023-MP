import datetime
import queue
#ФИО,дата рождения
my_data = ("Катков Максим Михайлович", 25, 2, 2003)
#оценки по аттестату
subject_grade = {
    "Русский": 4, 
    "литература": 5, 
    "алгебра": 4,
    "геометрия":4,
    "физика":5,
    "английиский":4,
    "химия":4,
    "биология":4,
    "информатика":5,
    "география":5,
    "обществознание":5,
    "астрономия":5,
    "история": 5, 
    "ОБЖ": 5,
    "Физкультура":5
    }
#имена близких родственников
family_names = ["Миша", "Василий", "Настя","Максим","Наташа" ,"Серёжа", "Катя","Миша"]
#имя своей киви
kiwa_name = "Мурзик"

def border():
    print('\n')
    for i in range(120):
        print('*',end='')
    print('\n')
    

 #1
# Средняя оценка по аттестату
border()
average_grade = sum(subject_grade.values()) / len(subject_grade.values())
print('№1  Средняя оценка по аттестату: '+ str(average_grade)+'\n')

 #2
# уникальные имена среди своих родственников (включая свое)
border()
unique_names = []
for name in family_names:
    if name in unique_names:
        continue
    unique_names.append(name)
print('№2  Уникальные имена среди своих родственников(включая свое):')
#вывод в столбик, переделаем в множество
u_names=set(family_names)
for i in u_names:
    print(i)

 #3
#общая длина всех названий предметов
border()
lenght=0
#нахожу список ключей словаря
for i in list(subject_grade):
    lenght+=(len(i))
print('\n'+'№3  Общая длина всех названий предметов: ',lenght,'\n')   
 
 #4
#уникальные буквы в названиях предметов
border()
letters_subject=[]
for i in list(subject_grade):
    #сделал список множества состоящий из элементов ключей словаря
    #extend - добавление словаря к словарю
     letters_subject.extend( list(set(i)))
unique_letters=set(letters_subject)
print('№4  Уникальные буквы в названиях предметов: ',*unique_letters,'\n')
   
 #5    
#имя вашей домашней пушистой кивы в бинарном виде
border()
print('№5  Имя домашней пушистой кивы в бинарном виде:'+'\n')
for char in bytearray(kiwa_name, 'utf-8'):
    print(bin(char))
    # .join-метод объединения списка строк с помощью указателя ' ',
    #map-функция для обработки обЪектов без цикла for,
    #bin() преобразует целое число в двоичную (бинарную) строку с префиксом '0b'
    #bytearray - массив байт
#kiwa_bin = ' '.join(map(bin, bytearray(kiwa_name, "utf-8")))
#print(kiwa_bin)

 #6
#Отсортированный по алфавиту (в обратном порядке) список родственников          
border()
sorted_names=sorted(list(family_names),reverse=True)
print('\n','№6  Отсортированный по алфавиту (в обратном порядке) список родственников:')
for i in sorted_names:
    print(i)
    
 #7
#Количество дней от вашей даты рождения до текущей даты (должна быть всегда актуальной)
border()
date_now=datetime.datetime.today()
date_old=datetime.datetime(day=25,month=2,year=2003)
print('\n','№7  Количество дней от вашей даты рождения до текущей даты (должна быть всегда актуальной):','\n',date_now-date_old)

 #8
#FIFO очередь, в которую можно добавлять предметы по вводимому с клавиатуры индексу (до команды остановки),
#после введения - вывести все
border()
#создаем очередь
q=queue.Queue()
#заполняем очередь ключами
for i in list(subject_grade):
    q.put(i)
print('\n','№8  Добавьте предмет ','\n')
#добавляем новые элементы к очереди с помощью метода .put()
print('Добавляем новые элементы к очереди \n')
while True:
    subject=input('Нажмите Enter,чтобы прекратить ввод с клавиатуры: ')
    if subject=='':
        break
    else:
        q.put(subject)
#возвращаем элементы очереди с помощью метода .get(), метод .empty() возвращает True если очередь пустая, иначе False
print('\n','Выввод всех предметов:')
while True:
    print(q.get())
    if q.empty()==True:
        break
print('\n')
#9 
#по введенному индексу, поменять имя в отсортированном списке родственников на имя ацтекского правителя под номером, 
#полученным из вашей статистики рождения: число = (день + месяц**2 + год) % 21 + 1
border()
print('№9 по введенному индексу, поменять имя в отсортированном списке родственников на имя ацтекского правителя',end='')
print('под номером, полученным из вашей статистики рождения: число = (день + месяц**2 + год) % 21 + 1','\n')
Acteck_names=['Теноч','Акамапичтли','Уицилиуитль','Чимальпопока','Шиуитль Темок','Ицкоатль','Моктесума I','Атотоцтли','Ахаякатль','Тизок','Ауисотль','Моктесума II','Куитлауак','Куаутемок','Тлакоцин','Мотельчиуцин','Сочикенцин','Хуаницин','Техуэцкитицин','Сечетцин','Сипак']
i=int(input('Введите индекс списка имен Родственников,отсортированный по алфавиту (в обратном порядке):'))
#номер имени правителя 
n=(my_data[1]+(my_data[2])**2+my_data[3])%21+1
#меняем имена местами
print('\n','Имя ',sorted_names[i],' поменяно на ',end='')
sorted_names[i]=Acteck_names[n-1]
print(sorted_names[i])

#10
# Создать связной список, например, как словарь, где - ключ имя родственника, 
#значение (ссылка на следующий элемент) - индекс имени по исходному списку,
#упорядоченному по их (родственников) годам рождения), исходный список при этом должен остаться
#Василий,Наташа,Миша,Сережа,Настя,Максим,Катя,Миша
border()
print('\n','#10 создать связной список, например, как словарь, где - ключ имя родственника, значение (ссылка на следующий элемент) - индекс имени по исходному списку, упорядоченному по их (родственников) годам рождения), исходный список при этом должен остаться ')
print('\n','От старшего к младшему: Василий 1952,Наташа 1972,Миша 1973 ,Сережа 1979,Настя 1995,Максим 2003,Катя 2004,Миша 2011','\n')
family_names_by = { "Василий":1,"Наташа":2 ,"Миша":3,"Серёжа":4, "Настя":5,"Максим":6,"Катя":7,"Миша":0}

print(family_names_by)
    
#11
# Написать функцию-генератор, свой вариант Решение как number = len("ФИО") * len (family_names) % 4
border()
print('\n','#11 Написать функцию-генератор, свой вариант Решение как number = len("ФИО") * len (family_names) % 4,аликвотная последовательность\n')
number=len(my_data[0])*len(family_names)%4
print('number=',number,'-аликвотная последовательность-это последовательность в которой каждый член является суммой собственных делителей предыдущего члена \n')
#аликвотная последовательность
#Функция для нахождения собственных делителей числа- возвращает объект генератор
def divisors(n):
    for i in range(1,n):
        if n % i==0:
            yield i

n=int(input('Введите значение числа n ,с которого начнётся последовательность n= '))
count=0 #счётчик итераций
alikvota_sequence=[]

while n!=0:
    a=0
    for i in divisors(n):
        a += i
    n=a
    alikvota_sequence.append(a)
    count+=1
    # Поставлю ограничение на запись элементов последовательности ,т.к. последовательность может иметь бесконечное число элементов
    # Например для n=25 - последователбность будет состоять из бесконечных значений равных числу 6
    if count==500:
        break
print('\n','Аликвотная последовательность: ',alikvota_sequence)
